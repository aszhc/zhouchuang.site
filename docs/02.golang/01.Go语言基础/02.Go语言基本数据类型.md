---
title: 基本数据类型
date: 2024-09-13 12:10:05
permalink: /pages/2c6b56/
categories:
  - go
tags:
  - go 基础
author: 
  name: ZhouChuang
  link: https://github.com/aszhc
---

> Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。

基础类型，包括：数字、字符串和布尔型。

复合数据类型：数组和结构体，它是通过组合简单类型，来表达更加复杂的数据结构。

引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝。

## 整型

Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。

其中，`uint8`就是我们熟知的`byte`型，`int16`对应C语言中的`short`型，`int64`对应C语言中的`long`型。

|  类型  | 描述                                                         |
| :----: | :----------------------------------------------------------- |
| uint8  | 无符号 8位整型 (0 到 255)                                    |
| uint16 | 无符号 16位整型 (0 到 65535)                                 |
| uint32 | 无符号 32位整型 (0 到 4294967295)                            |
| uint64 | 无符号 64位整型 (0 到 18446744073709551615)                  |
|  int8  | 有符号 8位整型 (-128 到 127)                                 |
| int16  | 有符号 16位整型 (-32768 到 32767)                            |
| int32  | 有符号 32位整型 (-2147483648 到 2147483647)                  |
| int64  | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |

> 特殊整型

|  类型   | 描述                                                   |
| :-----: | :----------------------------------------------------- |
|  uint   | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` |
|   int   | 32位操作系统上就是`int32`，64位操作系统上就是`int64`   |
| uintptr | 无符号整型，用于存放一个指针                           |

<font color="red">**注意**</font>  对于 uint 和 int，因为不同的编译器即使在相同的硬件平台上可能产生不同的大小，所以不能假定它是32位或64位的整型。

二进制、八进制、十六进制的格式可以采用数字字面量语法的方式来定义。

`v:=0b00101101`，代表二进制的 101101，相当于十进制的 45。 八进制数以`0`开头，也可以使用`0o`或`0O`(字母O)前缀来明确表示这是一个八进制数，例如`v := 0o377`，代表八进制的 377，相当于十进制的 255。`v := 0x1p-2`，代表十六进制的 1 除以 2²，也就是 0.25。

```go
package main
 
import "fmt"
 
func main(){
	// 十进制
	var a int = 10
	fmt.Printf("%d \n", a)  // 10
	fmt.Printf("%b \n", a)  // 1010  占位符%b表示二进制
 
	// 八进制  以0开头
	var b int = 077
	fmt.Printf("%o \n", b)  // 77
 
	// 十六进制  以0x开头
	var c int = 0xff
	fmt.Printf("%x \n", c)  // ff
	fmt.Printf("%X \n", c)  // FF
}

```

## 浮点型

Go语言支持两种浮点型数：`float32`和`float64`。这两种浮点型数据格式遵循`IEEE 754 `标准： `float32` 的浮点数的最大范围约为 `3.4e38`，可以使用常量定义：`math.MaxFloat32`。 `float64` 的浮点数的最大范围约为 `1.8e308`，可以使用一个常量定义：`math.MaxFloat64`。

```go
func main() {
    fmt.Printf("%f\n", math.Pi)
    fmt.Printf("%.2f\n", math.Pi)
}
```

## 复数

complex64和complex128

```go
var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1)
fmt.Println(c2)
```

复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。

这里仅做简单介绍，复数的使用场景在工作中比较少。

## 布尔值

Go语言中以`bool`类型进行声明布尔型数据，布尔型数据只有`true（真）`和`false（假）`两个值。

**注意：**

1. 布尔类型变量的默认值为`false`。
2. Go 语言中不允许将整型强制转换为布尔型.
3. 布尔型无法参与数值运算，也无法与其他类型进行转换。

## 字符串

字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

内置的len函数可以返回一个字符串中的字节数目，索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束。

```go
s := "hello, world"
fmt.Println(len(s))     // "12"
fmt.Println(s[0], s[7]) // "104 119" ('h' and 'w')
```

如果试图访问超出字符串索引范围的字节将会导致panic异常：

```Go
c := s[len(s)] // panic: index out of range
```

第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。

子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。

```Go
fmt.Println(s[0:5]) // "hello"
```

同样，如果索引超出字符串范围或者j小于i的话将导致panic异常。

```go
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:])  // "hello, world"
```

`+`操作符将两个字符串连接构造一个新字符串：

```Go
fmt.Println("goodbye" + s[5:]) // "goodbye, world"
```

字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变。

不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。

![img](http://cdn.zhouchuang.site/img/20240913142629.png)

> 转义字符

| 转义符 | 含义                               |
| :----: | :--------------------------------- |
|  `\r`  | 回车符（返回行首）                 |
|  `\n`  | 换行符（直接跳到下一行的同列位置） |
|  `\t`  | 制表符                             |
|  `\'`  | 单引号                             |
|  `\"`  | 双引号                             |
|  `\\`  | 反斜杠                             |

> 多行字符串

Go语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```go
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```

反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

> 字符串的常用操作

| 方法                                | 介绍                 |
| :---------------------------------- | :------------------- |
| len(str)                            | 求长度               |
| +或fmt.Sprintf                      | 拼接字符串           |
| strings.Split                       | 分割                 |
| strings.contains                    | 判断是否包含         |
| strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断        |
| strings.Index(),strings.LastIndex() | 子串出现的位置       |
| strings.Join(a[]string, sep string) | join操作，合并字符串 |

大小写：ToUpper()、ToLower()

去除字符串首尾空格：TrimSpace()

分割：Split()、SplitN()、SplitAfter()、SplitAfterN()

## byte 和 rune 类型

组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```go
var a = '周'
var b = 'x'
```

Go 语言的字符有以下两种：

1. `uint8`类型，或者叫 byte 型，代表一个`ASCII码`字符。
2. `rune`类型，代表一个 `UTF-8字符`。

当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型实际是一个`int32`。

```go
// 遍历字符串
func traversalString() {
    s := "hello 中国"
    for i := 0; i < len(s); i++ { //byte
       fmt.Printf("%v(%c) ", s[i], s[i])
    }
    fmt.Println()
    for _, r := range s { //rune
       fmt.Printf("%v(%c) ", r, r)
    }
    fmt.Println()
}
```

输出：

```bash
104(h) 101(e) 108(l) 108(l) 111(o) 32( ) 228(ä) 184(¸) 173(­) 229(å) 155() 189(½) 
104(h) 101(e) 108(l) 108(l) 111(o) 32( ) 20013(中) 22269(国) 
```

因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

> 修改字符串

既然字符串不能变，那如何修改字符串呢，可以先转换成`[]byte`或者`[]rune`，然后再转换为`string`。

```go
func changeString() {
	s1 := "big"
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := "白萝卜"
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
```

## 类型转换

Go 语言中只有强制类型转换，没有隐式类型转换。

强制类型转换的基本语法如下：

```bash
T(表达式)
```

其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.
